---
title: "Design your schema"
description: "A guide for designing your schema in a Ponder app."
---

import { Callout } from "nextra/components";

# Design your schema

Ponder's schema definition API is built on [Drizzle](https://orm.drizzle.team/), a modern TypeScript ORM.

{/* If you're familiar with Drizzle, the `ponder.schema.ts` file works just like a Drizzle schema file. */}

## Tables

To create a table, use the `onchainTable` function exported by `@ponder/core` and include column definitions.

```ts filename="ponder.schema.ts" {1,3}
import { onchainTable } from "@ponder/core";

export const pets = onchainTable("pets", (t) => ({
  name: t.text().primaryKey(),
  age: t.int().notNull(),
}));
```

<Callout type="info">
  Remember to export table objects using `export const`. Ponder will ignore
  tables that are not exported.
</Callout>

### Table name

### Primary key

### Indexes

## Columns

### Standard column types

The schema definition API supports **all PostgreSQL data types**.

Here's a quick reference for the most commonly used data types. For a complete list, see the [Drizzle documentation](https://orm.drizzle.team/docs/column-types/pg).

| name           | description                        | TypeScript type          | SQL data type   |
| :------------- | :--------------------------------- | :----------------------- | :-------------- |
| `text{:ts}`    | UTF‐8 character sequence           | `string`                 | `TEXT{:sql}`    |
| `int{:ts}`     | Signed 4‐byte integer              | `number`                 | `INTEGER{:sql}` |
| `real{:ts}`    | Signed 8-byte floating‐point value | `number`                 | `REAL{:sql}`    |
| `boolean{:ts}` | `true` or `false`                  | `boolean`                | `BOOLEAN{:sql}` |
| `json{:ts}`    | JSON object                        | `any` or [custom](#json) | `JSON{:sql}`    |

### EVM column types

Ponder also includes a few extra column types to handle common EVM indexing scenarios.

| name          | description                                  | TypeScript type | SQL data type         |
| :------------ | :------------------------------------------- | :-------------- | :-------------------- |
| `bigint{:ts}` | Large integer (holds `uint256` and `int256`) | `bigint`        | `NUMERIC(78,0){:sql}` |
| `hex{:ts}`    | UTF‐8 character sequence with `0x` prefix    | `0x${string}`   | `TEXT{:sql}`          |

#### `bigint`

The `bigint` column type can hold any EVM `uint256` or `int256` value.

```ts filename="ponder.schema.ts" {5}
import { onchainTable } from "@ponder/core";

export const accounts = onchainTable("accounts", (t) => ({
  address: t.hex().primaryKey(),
  balance: t.bigint().notNull(),
}));
```

<Callout type="info">
  Ponder's `bigint` type takes precedence over the Drizzle
  [`bigint`](https://orm.drizzle.team/docs/column-types/pg#bigint) type.
  Drizzle's `bigint` is an 8-byte integer, which is not large enough to hold EVM
  `uint256` or `int256` values. If you want to use an 8-byte integer, you can
  still use the `int8` alias.
</Callout>

#### `hex`

The `hex` column type is useful for EVM `address`, `bytes`, or any other hex-encoded value.

((something about being byte aligned))

```ts filename="ponder.schema.ts" {4}
import { onchainTable } from "@ponder/core";

export const accounts = onchainTable("accounts", (t) => ({
  address: t.hex().primaryKey(),
  balance: t.bigint().notNull(),
}));
```

### Enums

To define an enum, use the `onchainEnum` function exported by `@ponder/core`. Then, use the value returned by `onchainEnum` as a column type. Under the hood, `onchainEnum` uses a PostgreSQL [enumerated type](https://www.postgresql.org/docs/current/datatype-enum.html).

```ts filename="ponder.schema.ts" {3,7}
import { onchainEnum } from "@ponder/core";

export const color = onchainEnum("color", ["ORANGE", "BLACK"]);

export const cats = onchainTable("cats", (t) => ({
  name: t.text().primaryKey(),
  color: color("color"),
}));
```

### Best practices

#### Timestamps

Consider using the `bigint` column type to store block timestamp values as their EVM `uint256` representation. If you prefer working with JavaScript `Date` objects, you could also use the `timestamp` column type.

```ts filename="ponder.schema.ts" {5,6}
import { onchainTable } from "@ponder/core";

export const events = onchainTable("events", (t) => ({
  id: t.text().primaryKey(),
  timestamp: t.bigint(), // Unix timestamp in seconds
  timestampDate: t.timestamp(), // JavaScript Date object
}));
```

#### JSON

Use the `.$type()` modifier to specify a type-level schema for JSON columns. Note that this does not validate data at runtime or in the database.

{/* prettier-ignore */}
```ts filename="ponder.schema.ts" {5}
import { onchainTable } from "@ponder/core";

export const tokens = onchainTable("tokens", (t) => ({
  id: t.bigint().primaryKey(),
  metadata: t.json().$type<{ name: string; symbol: string; decimals: number }>(),
}));
```

## Relationships

Ponder uses Drizzle Relations to define relationships between tables. Here are some examples of how to define one-to-one, one-to-many, and many-to-many relationships. For more information, see the [Drizzle Relations documentation](https://orm.drizzle.team/docs/relations).

<Callout type="info">
  Relations are useful to connect tables in the Query API (`findMany` and
  `findFirst`) and the GraphQL API. However, relations **do not** create foreign
  key constraints and won't stop you from inserting rows that violate
  referential integrity.
</Callout>

### One-to-one

Use the `relations` function exported by `@ponder/core` to define the relationships for a table.

To define a one-to-one relationship, use the `one()` operator and specify which columns relate the two tables. In this example, each user has a profile and each profile belongs to one user.

```ts filename="ponder.schema.ts" {1,7-9}
import { onchainTable, relations } from "@ponder/core";

export const users = onchainTable("users", (t) => ({
  id: t.text().primaryKey(),
}));

export const usersRelations = relations(users, ({ one }) => ({
  profile: one(profiles, { fields: [users.id], references: [profiles.userId] }),
}));

export const profiles = onchainTable("profiles", (t) => ({
  id: t.text().primaryKey(),
  userId: t.text().notNull(),
  age: t.int().notNull(),
}));
```

Now that you've defined the relationship, the `profile` field will become available in the Query API (`findMany` and `findFirst`) using the `with` option.

```ts filename="src/index.ts" {8,11}
import { users, profiles } from "../ponder.schema";

await db.insert(users).values({ id: "hunter42" });
await db.insert(profiles).values({ userId: "hunter42", age: 29 });

const user = await db.sql.query.users.findFirst({
  where: eq(users.id, "hunter42"),
  with: { profile: true },
});

console.log(user.profile.age);
//          ^? { id: string; profile: { id: string; userId: string; age: number } }
```

### One-to-many

To define a one-to-many relationship, use the `one()` and `many()` operators to define both sides of the relationship. In this example, each dog has one owner and each person can own many dogs.

```ts filename="ponder.schema.ts" {7-9,16-18}
import { onchainTable, relations } from "@ponder/core";

export const persons = onchainTable("persons", (t) => ({
  name: t.text().primaryKey(),
}));

export const personsRelations = relations(persons, ({ many }) => ({
  dogs: many(dogs),
}));

export const dogs = onchainTable("dogs", (t) => ({
  petId: t.text().primaryKey(),
  ownerName: t.text().notNull(),
}));

export const dogsRelations = relations(dogs, ({ one }) => ({
  owner: one(persons, { fields: [dogs.ownerName], references: [persons.name] }),
}));
```

Now, any row inserted into the `dogs` table with `ownerName: "Bob"` will become available in Bob's `dogs` field.

```ts filename="src/index.ts" {11,15}
import { persons, dogs } from "../ponder.schema";

await db.insert(persons).values({ name: "Bob" });
await db.insert(dogs).values([
  { petId: "Chip", ownerName: "Bob" },
  { petId: "Spike", ownerName: "Bob" },
]);

const bob = await db.sql.query.persons.findFirst({
  where: eq(persons.id, "Bob"),
  with: { dogs: true },
});

console.log(bob.dogs);
//          ^? { name: string; dogs: { petId: string; age: number }[] }
```

<Callout type="info">
  Note that in a one-to-many relationship, you cannot directly set the value of
  the `many` field. Instead, you must insert or update the related records
  individually.
</Callout>

### Many-to-many

To define a many-to-many relationship, create a "join table" that relates the two tables you want to connect using two one-to-many relationships.

To create a relationship, insert a row into the join table.

```ts filename="ponder.schema.ts" {7,11,15,16}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Person: p.createTable({
    id: p.string(),
    age: p.int(),
    personDogs: p.many("PersonDog.personId"),
  }),
  Dog: p.createTable({
    id: p.string(),
    personDogs: p.many("PersonDog.dogId"),
  }),
  PersonDog: p.createTable({
    id: p.string(),
    personId: p.string().references("Person.id"),
    dogId: p.string().references("Dog.id"),
    person: p.one("personId"),
    dog: p.one("dogId"),
  }),
}));
```

### Relationships in GraphQL

#### One-to-one in GraphQL

Now, you can query for information about the owner of a dog using the GraphQL API.

<div className="code-columns">

{/* prettier-ignore */}
```graphql filename="Query" {4-6}
query {
  dog(id: "Chip") {
    id
    owner {
      age
    }
  }
}
```

{/* prettier-ignore */}
```json filename="Result" {4-6}
{
  "dog": {
    "id": "Chip",
    "owner": {
      "age": 22,
    },
  },
}
```

</div>

Then, you can write GraphQL queries for one-to-many data on either side of the relationship. In this example, you could query for all of a person's dogs, or all of a dog's people.

<div className="code-columns">

{/* prettier-ignore */}
```graphql filename="Query" {4-8}
query {
  person(id: "Max") {
    id
    personDogs {
      dog {
        id
      }
    }
  }
  dog(id: "Chip") {
    id
    personDogs {
      person {
        id
      }
    }
  }
}
```

{/* prettier-ignore */}
```json filename="Result" {4-8}
{
  "person": {
    "id": "Max",
    "personDogs": [
      { "dog": { "id": "Chip" } },
      { "dog": { "id": "Spike" } },
      { "dog": { "id": "Lettuce" } },
    ],
  },
  "dog": {
    "id": "Chip",
    "personDogs": [
      { "person": { "id": "Max" } },
    ],
  },
}
```

</div>

#### One-to-many in GraphQL

<div className="code-columns">

{/* prettier-ignore */}
```graphql filename="Query"
query {
  person(id: "Bob") {
    id
    dogs {
      id
    }
  }
}
```

{/* prettier-ignore */}
```json filename="Result"
{
  "person": {
    "id": "Bob",
    "dogs": [
      { "id": "Chip" },
      { "id": "Spike" }
    ]
  }
}
```

</div>

As a reminder, you cannot directly get or set the `dogs` field on a `Person` record. Columns defined using `p.one(){:ts}` and `p.many(){:ts}` don't exist in the database. They are only present when querying data from the GraphQL API.

<div className="code-columns">

```ts filename="src/index.ts"
const { Person } = context.db;

await Person.create({
  id: "Bob",
  // Error, can't set a virtual column.
  data: { dogs: ["Chip", "Bob"] },
});
```

```ts filename="src/index.ts"
const { Person } = context.db;

const bob = await Person.get("Bob");
// `dogs` field is NOT present.
// {
//   id: "Bob"
// }
```

</div>

## Indexes

To create a database index, include a second argument to the `p.createTable(){:ts}` function, and use `p.index(){:ts}` to specify which column(s) to include in the index.

<Callout type="info">
  Database indexes are created _after_ historical indexing is complete, just
  before the app becomes healthy.
</Callout>

### Single column

To create a index on a single column, pass the column name to `p.index(){:ts}`.

{/* prettier-ignore */}
```ts filename="ponder.schema.ts" {10,17}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Person: p.createTable({
    id: p.string(),
    name: p.string(),
    dogs: p.many("Dog.ownerId"),
  }, {
    // Index the `name` column to speed up search queries.
    nameIndex: p.index("name"),
  }),
  Dog: p.createTable({
    id: p.string(),
    ownerId: p.string().references("Person.id"),
  }, {
    // Index the `ownerId` column to speed up relational queries (the `Person.dogs` field).
    ownerIdIndex: p.index("ownerId"),
  }),
}));
```

For single-column indexes, you can also specify the direction of the index using `.asc(){:ts}` or `.desc(){:ts}`, and the null ordering behavior using `.nullsFirst(){:ts}` or `.nullsLast(){:ts}`. These options can improve query performance if you use the column in an `ORDER BY{:sql}` clause using the same options.

```ts filename="ponder.schema.ts" {6}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Person: p.createTable(
    { id: p.string(), age: p.string() },
    { ageIndex: p.index("age").asc().nullsLast() }
  ),
}));
```

### Multiple columns

To create a multi-column index, pass an array of column names to `p.index(){:ts}`. The index will be created using the same column order that you specify.

{/* prettier-ignore */}
```ts filename="ponder.schema.ts" {9}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Person: p.createTable({
    id: p.string(),
    age: p.int(),
    salary: p.bigint(),
  }, {
    seniorityIndex: p.index(["age", "salary"]),
  }),
}));
```

The `.asc(){:ts}`, `.desc(){:ts}`, `.nullsFirst(){:ts}` and `.nullsLast(){:ts}` modifiers are not currently supported for multi-column indexes.

## ERC20 example

Here's a schema for a simple ERC20 app.

```ts filename="ponder.schema.ts"
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Account: p.createTable({
    id: p.string(),
    balance: p.bigint(),
    isOwner: p.boolean(),
    approvals: p.many("Approval.ownerId"),
    transferFromEvents: p.many("TransferEvent.fromId"),
    transferToEvents: p.many("TransferEvent.toId"),
  }),
  Approval: p.createTable({
    id: p.string(),
    amount: p.bigint(),
    spender: p.string(),
    ownerId: p.string().references("Account.id"),
    owner: p.one("ownerId"),
  }),
  TransferEvent: p.createTable({
    id: p.string(),
    amount: p.bigint(),
    fromId: p.string().references("Account.id"),
    toId: p.string().references("Account.id"),
    timestamp: p.int(),
    from: p.one("fromId"),
    to: p.one("toId"),
  }),
}));
```

## Old

Here's an example `Account` table that has a column of every type, and a function that inserts an `Account` record.

<div className="code-columns">

```ts filename="ponder.schema.ts"
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Account: p.createTable({
    id: p.hex(),
    daiBalance: p.bigint(),
    totalUsdValue: p.float(),
    lastActiveAt: p.int(),
    isAdmin: p.boolean(),
    graffiti: p.string(),
    extra: p.json(),
  }),
}));
```

```ts filename="src/index.ts"
const { Account } = context.db;

await Account.create({
  id: "0xabc",
  data: {
    daiBalance: 7770000000000000000n,
    totalUsdValue: 17.38,
    lastActiveAt: 1679337733,
    isAdmin: true,
    graffiti: "LGTM",
    extra: {
      middleName: "james",
    },
  },
});
```

</div>

### Enum

To define a enum, pass a list of allowable values to `p.createEnum(){:ts}` (similar to `p.createTable(){:ts}`). Then use `p.enum(){:ts}` as a column type, passing the enum name as an argument. Enums use the same database and JSON types as `string` columns.

<div className="code-columns">

```ts filename="ponder.schema.ts" {4,7}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Color: p.createEnum(["ORANGE", "BLACK"]),
  Cat: p.createTable({
    id: p.string(),
    color: p.enum("Color"),
  }),
}));
```

```ts filename="src/index.ts" {6}
const { Cat } = context.db;

await Cat.create({
  id: "Fluffy",
  data: {
    color: "ORANGE",
  },
});
```

</div>

### List

To define a list, add `.list(){:ts}` to any primitive or enum column. Lists should only be used for small one-dimenional collections, not relationships between records.

<div className="code-columns">

```ts filename="ponder.schema.ts" {7}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Color: p.createEnum(["ORANGE", "BLACK"]),
  FancyCat: p.createTable({
    id: p.string(),
    favoriteNumbers: p.int().list(),
    colors: p.enum("Color").list(),
  }),
}));
```

```ts filename="src/index.ts" {6}
const { FancyCat } = context.db;

await FancyCat.create({
  id: "Fluffy",
  data: {
    favoriteNumbers: [7, 420, 69],
    colors: ["ORANGE", "BLACK"],
  },
});
```

</div>

### Optional

All columns are **required** by default (`NOT NULL{:sql}`). To mark a column as optional/nullable, add `.optional(){:ts}` to the primitive type.

<div className="code-columns">

```ts filename="ponder.schema.ts" {7}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  User: p.createTable({
    id: p.hex(),
    ens: p.string(),
    github: p.string().optional(),
  }),
}));
```

```ts filename="src/index.ts" {6-7,14}
const { User } = context.db;

await User.create({
  id: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
  data: {
    ens: "vitalik.eth",
    github: "https://github.com/vbuterin",
  },
});

await User.create({
  id: "0xD7029BDEa1c17493893AAfE29AAD69EF892B8ff2",
  data: {
    ens: "dwr.eth",
  },
});
```

</div>

### Foreign key

Foreign key columns are used to define relationships between records. To define a foreign key column:

1. Add `.references("OtherTable.id"){:ts}` to the column type.
2. Be sure to use the same column type as the referenced column.
3. By convention, the foreign key column name should have an `Id` suffix, like `userId` or `tokenId`.

Foreign key columns are just like other primitive columns. They are persisted to the database, and if they are not marked as optional, they must included when creating new records.

```ts filename="ponder.schema.ts" {11,16}
import { createSchema } from "@ponder/core";

export default createSchema((p) => ({
  Author: p.createTable({
    id: p.bigint(),
    name: p.string(),
  }),
  Book: p.createTable({
    id: p.string(),
    title: p.string(),
    authorId: p.bigint().references("Author.id"),
  }),
  Page: p.createTable({
    id: p.bigint(),
    contents: p.string(),
    bookId: p.string().references("Book.id"),
  }),
}));
```

<Callout type="info">
Foreign key columns can only reference primary key columns of other tables. This is because the schema definition does not yet support marking columns other than the primary key as `DISTINCT{:sql}`/`UNIQUE{:sql}`. We may add this feature in a future release - please get in touch if you want it.
</Callout>
